---
sidebarTitle: initiate_swarm_chat
title: autogen.initiate_swarm_chat
---

<code class="doc-symbol doc-symbol-heading doc-symbol-function"></code>
#### initiate_swarm_chat

```python
initiate_swarm_chat(
    initial_agent: ConversableAgent,
    messages: list[dict[str, Any]] | str,
    agents: list[ConversableAgent],
    user_agent: UserProxyAgent | None = None,
    swarm_manager_args: dict[str, Any] | None = None,
    max_rounds: int = 20,
    context_variables: dict[str, Any] | None = None,
    after_work: AfterWorkOption | Callable[..., Any] | None = AfterWork(agent=&lt;AfterWorkOption.TERMINATE: &#x27;TERMINATE&#x27;&gt;, next_agent_selection_msg=None),
    exclude_transit_message: bool = True
) -> tuple[ChatResult, dict[str, Any], ConversableAgent]
```

    Initialize and run a swarm chat

<b>Parameters:</b>
| Name | Description |
|--|--|
| `initial_agent` | The first receiving agent of the conversation.<br/><br/>**Type:** [ConversableAgent](/docs/api-reference/autogen/ConversableAgent) |
| `messages` | Initial message(s).<br/><br/>**Type:** list[dict[str, typing.Any]] \| str |
| `agents` | list of swarm agents.<br/><br/>**Type:** list[[ConversableAgent](/docs/api-reference/autogen/ConversableAgent)] |
| `user_agent` | Optional user proxy agent for falling back to.<br/><br/>**Type:** [UserProxyAgent](/docs/api-reference/autogen/UserProxyAgent) \| None<br/><br/>**Default:** None |
| `swarm_manager_args` | Optional group chat manager arguments used to establish the swarm's groupchat manager, required when AfterWorkOption.SWARM_MANAGER is used.<br/><br/>**Type:** dict[str, typing.Any] \| None<br/><br/>**Default:** None |
| `max_rounds` | Maximum number of conversation rounds.<br/><br/>**Type:** int<br/><br/>**Default:** 20 |
| `context_variables` | Starting context variables.<br/><br/>**Type:** dict[str, typing.Any] \| None<br/><br/>**Default:** None |
| `after_work` | Method to handle conversation continuation when an agent doesn't select the next agent.<br/><br/>If no agent is selected and no tool calls are output, we will use this method to determine the next agent.<br/><br/>Must be a AfterWork instance (which is a dataclass accepting a ConversableAgent, AfterWorkOption, A str (of the AfterWorkOption)) or a callable.<br/><br/>AfterWorkOption: - TERMINATE (Default): Terminate the conversation.<br/><br/>- REVERT_TO_USER : Revert to the user agent if a user agent is provided.<br/><br/>If not provided, terminate the conversation.<br/><br/>- STAY : Stay with the last speaker.<br/><br/>Callable: A custom function that takes the current agent, messages, and groupchat as arguments and returns an AfterWorkOption or a ConversableAgent (by reference or string name).<br/><br/>```def custom_afterwork_func(last_speaker: ConversableAgent, messages: List[Dict[str, Any]], groupchat: GroupChat) -> Union[AfterWorkOption, ConversableAgent, str]: ```<br/><br/>**Type:** [AfterWorkOption](/docs/api-reference/autogen/AfterWorkOption) \| Callable[..., Any] \| None = AfterWork(agent<br/><br/>**Default:** &lt;AfterWorkOption.TERMINATE |
| `exclude_transit_message` | all registered handoff function call and responses messages will be removed from message list before calling an LLM.<br/><br/>Note: only with transition functions added with `register_handoff` will be removed.<br/><br/>If you pass in a function to manage workflow, it will not be removed.<br/><br/>You may register a cumstomized hook to `process_all_messages_before_reply` to remove that.<br/><br/>**Type:** bool<br/><br/>**Default:** True |

<b>Returns:</b>
| Type | Description |
|--|--|
| tuple[[ChatResult](/docs/api-reference/autogen/ChatResult), dict[str, typing.Any], [ConversableAgent](/docs/api-reference/autogen/ConversableAgent)] | ChatResult: Conversations chat history. Dict[str, Any]: Updated Context variables. ConversableAgent: Last speaker. |

<br />