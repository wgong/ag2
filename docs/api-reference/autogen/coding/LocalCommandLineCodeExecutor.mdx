---
sidebarTitle: LocalCommandLineCodeExecutor
title: autogen.coding.LocalCommandLineCodeExecutor
---
<h2 id="autogen.coding.LocalCommandLineCodeExecutor" class="doc doc-heading">
    <code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>
    <span class="doc doc-object-name doc-class-name">LocalCommandLineCodeExecutor</span>
</h2>

```python
LocalCommandLineCodeExecutor(
    timeout: int = 60,
    virtual_env_context: SimpleNamespace | None = None,
    work_dir: Path | str = PosixPath('.'),
    functions: list[FunctionWithRequirements[Any, ~A] | Callable[..., Any] | FunctionWithRequirementsStr] = [],
    functions_module: str = 'functions',
    execution_policies: dict[str, bool] | None = None
)
```

    (Experimental) A code executor class that executes code blocks and returns the result.<br/>(Experimental) A code executor class that executes or saves LLM generated code a local command line
    environment.<br/>**This will execute or save LLM generated code on the local machine.**
    
    Each code block is saved as a file in the working directory. Depending on the execution policy,
    the code may be executed in a separate process.<br/>The code blocks are executed or save in the order they are received.<br/>Command line code is sanitized against a list of dangerous commands to prevent self-destructive commands from being executed,
    which could potentially affect the user's environment. Supported languages include Python, shell scripts (bash, shell, sh),
    PowerShell (pwsh, powershell, ps1), HTML, CSS, and JavaScript.<br/>Execution policies determine whether each language's code blocks are executed or saved only.<br/>## Execution with a Python virtual environment
    A python virtual env can be used to execute code and install dependencies. This has the added benefit of not polluting the
    base environment with unwanted modules.
    ```python
    from autogen.code_utils import create_virtual_env
    from autogen.coding import LocalCommandLineCodeExecutor
    
    venv_dir = ".venv"
    venv_context = create_virtual_env(venv_dir)
    
    executor = LocalCommandLineCodeExecutor(virtual_env_context=venv_context)
    ```

<b>Parameters:</b>
| Name | Description |
|--|--|
| `timeout` | **Type:** int<br/><br/>**Default:** 60 |
| `virtual_env_context` | **Type:** types.SimpleNamespace \| None<br/><br/>**Default:** None |
| `work_dir` | **Type:** pathlib.Path \| str<br/><br/>**Default:** PosixPath('.') |
| `functions` | **Type:** list[[FunctionWithRequirements](/docs/api-reference/autogen/coding/func_with_reqs/FunctionWithRequirements)[typing.Any, ~A] \| Callable[..., Any] \| [FunctionWithRequirementsStr](/docs/api-reference/autogen/coding/func_with_reqs/FunctionWithRequirementsStr)]<br/><br/>**Default:** [] |
| `functions_module` | **Type:** str<br/><br/>**Default:** 'functions' |
| `execution_policies` | **Type:** dict[str, bool] \| None<br/><br/>**Default:** None |

### Class Attributes

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### DEFAULT_EXECUTION_POLICY
<br />

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### FUNCTION_PROMPT_TEMPLATE
<br />

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### SUPPORTED_LANGUAGES
<br />

    <br />

### Static Methods

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### sanitize_command

```python
sanitize_command(lang: str, code: str) -> None
```

    Sanitize the code block to prevent dangerous commands.<br/>This approach acknowledges that while Docker or similar
    containerization/sandboxing technologies provide a robust layer of security,
    not all users may have Docker installed or may choose not to use it.<br/>Therefore, having a baseline level of protection helps mitigate risks for users who,
    either out of choice or necessity, run code outside of a sandboxed environment.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `lang` | **Type:** str |
| `code` | **Type:** str |

<br />

### Instance Attributes

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### code_extractor
<br />

    (Experimental) Export a code extractor that can be used by an agent.

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### functions
<br />

    (Experimental) The functions that are available to the code executor.

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### functions_module
<br />

    (Experimental) The module name for the functions.

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### timeout
<br />

    (Experimental) The timeout for code execution.

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### work_dir
<br />

    (Experimental) The working directory for the code execution.

### Instance Methods

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### execute_code_blocks

```python
execute_code_blocks(self, code_blocks: list[CodeBlock]) -> CommandLineCodeResult
```

    (Experimental) Execute the code blocks and return the result.<br/>

<b>Parameters:</b>
| Name | Description |
|--|--|
| `code_blocks` | The code blocks to execute.<br/><br/>**Type:** list[[CodeBlock](/docs/api-reference/autogen/coding/CodeBlock)] |

<b>Returns:</b>
| Type | Description |
|--|--|
| autogen.coding.base.CommandLineCodeResult | CommandLineCodeResult: The result of the code execution. |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### format_functions_for_prompt

```python
format_functions_for_prompt(self, prompt_template: str = 'You have access to the following user defined functions. They can be accessed from the module called `$module_name` by their function names.\n\nFor example, if there was a function called `foo` you could import it by writing `from $module_name import foo`\n\n$functions') -> str
```

    (Experimental) Format the functions for a prompt.<br/>The template includes two variables: <br/>- `$module_name`: The module name.<br/>- `$functions`: The functions formatted as stubs with two newlines between each function.<br/>

<b>Parameters:</b>
| Name | Description |
|--|--|
| `prompt_template` | The prompt template.<br/><br/>Default is the class default.<br/><br/>**Type:** str<br/><br/>**Default:** 'You have access to the following user defined functions. They can be accessed from the module called `$module_name` by their function names.\n\nFor example, if there was a function called `foo` you could import it by writing `from $module_name import foo`\n\n$functions' |

<b>Returns:</b>
| Type | Description |
|--|--|
| str | str: The formatted prompt. |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### restart

```python
restart(self) -> None
```

    (Experimental) Restart the code executor.

<br />