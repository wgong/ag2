---
sidebarTitle: GroupChat
title: autogen.GroupChat
---
<h2 id="autogen.GroupChat" class="doc doc-heading">
    <code class="doc-symbol doc-symbol-heading doc-symbol-class"></code>
    <span class="doc doc-object-name doc-class-name">GroupChat</span>
</h2>

```python
GroupChat(
    agents: list[Agent],
    messages: list[dict[str, Any]] = &lt;factory&gt;,
    max_round: int = 10,
    admin_name: str = 'Admin',
    func_call_filter: bool = True,
    speaker_selection_method: Literal['auto', 'manual', 'random', 'round_robin'] | Callable[..., Any] = 'auto',
    max_retries_for_selecting_speaker: int = 2,
    allow_repeat_speaker: bool | list[Agent] | None = None,
    allowed_or_disallowed_speaker_transitions: dict[str, Any] | None = None,
    speaker_transitions_type: Literal['allowed', 'disallowed', None] = None,
    enable_clear_history: bool = False,
    send_introductions: bool = False,
    select_speaker_message_template: str = 'You are in a role play game. The following roles are available:\n                {roles}.\n                Read the following conversation.\n                Then select the next role from {agentlist} to play. Only return the role.',
    select_speaker_prompt_template: str = 'Read the above conversation. Then select the next role from {agentlist} to play. Only return the role.',
    select_speaker_auto_multiple_template: str = 'You provided more than one name in your text, please return just the name of the next speaker. To determine the speaker use these prioritised rules:\n    1. If the context refers to themselves as a speaker e.g. "As the..." , choose that speaker\'s name\n    2. If it refers to the "next" speaker name, choose that name\n    3. Otherwise, choose the first provided speaker\'s name in the context\n    The names are case-sensitive and should not be abbreviated or changed.\n    Respond with ONLY the name of the speaker and DO NOT provide a reason.',
    select_speaker_auto_none_template: str = 'You didn\'t choose a speaker. As a reminder, to determine the speaker use these prioritised rules:\n    1. If the context refers to themselves as a speaker e.g. "As the..." , choose that speaker\'s name\n    2. If it refers to the "next" speaker name, choose that name\n    3. Otherwise, choose the first provided speaker\'s name in the context\n    The names are case-sensitive and should not be abbreviated or changed.\n    The only names that are accepted are {agentlist}.\n    Respond with ONLY the name of the speaker and DO NOT provide a reason.',
    select_speaker_transform_messages: TransformMessages | None = None,
    select_speaker_auto_verbose: bool | None = False,
    select_speaker_auto_model_client_cls: ModelClient | list[ModelClient] | None = None,
    select_speaker_auto_llm_config: dict[str, Any] | Literal[False] | None = None,
    role_for_select_speaker_messages: str | None = 'system'
)
```

    (In preview) A group chat class that contains the following data fields: <br/>- agents: a list of participating agents.<br/>- messages: a list of messages in the group chat.<br/>- max_round: the maximum number of rounds.<br/>- admin_name: the name of the admin agent if there is one. Default is "Admin".<br/>    KeyBoardInterrupt will make the admin agent take over.<br/>- func_call_filter: whether to enforce function call filter. Default is True.<br/>    When set to True and when a message is a function call suggestion,
        the next speaker will be chosen from an agent which contains the corresponding function name
        in its `function_map`.<br/>- select_speaker_message_template: customize the select speaker message (used in "auto" speaker selection), which appears first in the message context and generally includes the agent descriptions and list of agents. If the string contains "`\{roles}`" it will replaced with the agent's and their role descriptions. If the string contains "`\{agentlist}`" it will be replaced with a comma-separated list of agent names in square brackets. The default value is: <br/>    "You are in a role play game. The following roles are available: <br/>            `\{roles}`.<br/>            Read the following conversation.<br/>            Then select the next role from `\{agentlist}` to play. Only return the role."
    - select_speaker_prompt_template: customize the select speaker prompt (used in "auto" speaker selection), which appears last in the message context and generally includes the list of agents and guidance for the LLM to select the next agent. If the string contains "`\{agentlist}`" it will be replaced with a comma-separated list of agent names in square brackets. The default value is: <br/>    "Read the above conversation. Then select the next role from `\{agentlist}` to play. Only return the role."
        To ignore this prompt being used, set this to None. If set to None, ensure your instructions for selecting a speaker are in the select_speaker_message_template string.<br/>- select_speaker_auto_multiple_template: customize the follow-up prompt used when selecting a speaker fails with a response that contains multiple agent names. This prompt guides the LLM to return just one agent name. Applies only to "auto" speaker selection method. If the string contains "`\{agentlist}`" it will be replaced with a comma-separated list of agent names in square brackets. The default value is: <br/>    "You provided more than one name in your text, please return just the name of the next speaker. To determine the speaker use these prioritised rules: <br/>            1. If the context refers to themselves as a speaker e.g. "As the..." , choose that speaker's name
                2. If it refers to the "next" speaker name, choose that name
                3. Otherwise, choose the first provided speaker's name in the context
                The names are case-sensitive and should not be abbreviated or changed.<br/>            Respond with ONLY the name of the speaker and DO NOT provide a reason."
    - select_speaker_auto_none_template: customize the follow-up prompt used when selecting a speaker fails with a response that contains no agent names. This prompt guides the LLM to return an agent name and provides a list of agent names. Applies only to "auto" speaker selection method. If the string contains "`\{agentlist}`" it will be replaced with a comma-separated list of agent names in square brackets. The default value is: <br/>    "You didn't choose a speaker. As a reminder, to determine the speaker use these prioritised rules: <br/>            1. If the context refers to themselves as a speaker e.g. "As the..." , choose that speaker's name
                2. If it refers to the "next" speaker name, choose that name
                3. Otherwise, choose the first provided speaker's name in the context
                The names are case-sensitive and should not be abbreviated or changed.<br/>            The only names that are accepted are `\{agentlist}`.<br/>            Respond with ONLY the name of the speaker and DO NOT provide a reason."
    - speaker_selection_method: the method for selecting the next speaker. Default is "auto".<br/>    Could be any of the following (case insensitive), will raise ValueError if not recognized: <br/>    - "auto": the next speaker is selected automatically by LLM.<br/>    - "manual": the next speaker is selected manually by user input.<br/>    - "random": the next speaker is selected randomly.<br/>    - "round_robin": the next speaker is selected in a round robin fashion, i.e., iterating in the same order as provided in `agents`.<br/>    - a customized speaker selection function (Callable): the function will be called to select the next speaker.<br/>        The function should take the last speaker and the group chat as input and return one of the following: <br/>            1. an `Agent` class, it must be one of the agents in the group chat.<br/>            2. a string from ['auto', 'manual', 'random', 'round_robin'] to select a default method to use.<br/>            3. None, which would terminate the conversation gracefully.<br/>        ```python
            def custom_speaker_selection_func(
                last_speaker: Agent, groupchat: GroupChat
            ) -> Union[Agent, str, None]: <br/>        ```
    - max_retries_for_selecting_speaker: the maximum number of times the speaker selection requery process will run.<br/>    If, during speaker selection, multiple agent names or no agent names are returned by the LLM as the next agent, it will be queried again up to the maximum number
        of times until a single agent is returned or it exhausts the maximum attempts.<br/>    Applies only to "auto" speaker selection method.<br/>    Default is 2.<br/>- select_speaker_transform_messages: (optional) the message transformations to apply to the nested select speaker agent-to-agent chat messages.<br/>    Takes a TransformMessages object, defaults to None and is only utilised when the speaker selection method is "auto".<br/>- select_speaker_auto_verbose: whether to output the select speaker responses and selections
        If set to True, the outputs from the two agents in the nested select speaker chat will be output, along with
        whether the responses were successful, or not, in selecting an agent
        Applies only to "auto" speaker selection method.<br/>- allow_repeat_speaker: whether to allow the same speaker to speak consecutively.<br/>    Default is True, in which case all speakers are allowed to speak consecutively.<br/>    If `allow_repeat_speaker` is a list of Agents, then only those listed agents are allowed to repeat.<br/>    If set to False, then no speakers are allowed to repeat.<br/>    `allow_repeat_speaker` and `allowed_or_disallowed_speaker_transitions` are mutually exclusive.<br/>- allowed_or_disallowed_speaker_transitions: dict.<br/>    The keys are source agents, and the values are agents that the key agent can/can't transit to,
        depending on speaker_transitions_type. Default is None, which means all agents can transit to all other agents.<br/>    `allow_repeat_speaker` and `allowed_or_disallowed_speaker_transitions` are mutually exclusive.<br/>- speaker_transitions_type: whether the speaker_transitions_type is a dictionary containing lists of allowed agents or disallowed agents.<br/>    "allowed" means the `allowed_or_disallowed_speaker_transitions` is a dictionary containing lists of allowed agents.<br/>    If set to "disallowed", then the `allowed_or_disallowed_speaker_transitions` is a dictionary containing lists of disallowed agents.<br/>    Must be supplied if `allowed_or_disallowed_speaker_transitions` is not None.<br/>- enable_clear_history: enable possibility to clear history of messages for agents manually by providing
        "clear history" phrase in user prompt. This is experimental feature.<br/>    See description of GroupChatManager.clear_agents_history function for more info.<br/>- send_introductions: send a round of introductions at the start of the group chat, so agents know who they can speak to (default: False)
    - select_speaker_auto_model_client_cls: Custom model client class for the internal speaker select agent used during 'auto' speaker selection (optional)
    - select_speaker_auto_llm_config: LLM config for the internal speaker select agent used during 'auto' speaker selection (optional)
    - role_for_select_speaker_messages: sets the role name for speaker selection when in 'auto' mode, typically 'user' or 'system'. (default: 'system')

<b>Parameters:</b>
| Name | Description |
|--|--|
| `agents` | **Type:** list[[Agent](/docs/api-reference/autogen/Agent)] |
| `messages` | **Type:** list[dict[str, typing.Any]]<br/><br/>**Default:** &lt;factory&gt; |
| `max_round` | **Type:** int<br/><br/>**Default:** 10 |
| `admin_name` | **Type:** str<br/><br/>**Default:** 'Admin' |
| `func_call_filter` | **Type:** bool<br/><br/>**Default:** True |
| `speaker_selection_method` | **Type:** Literal['auto', 'manual', 'random', 'round_robin'] \| Callable[..., Any]<br/><br/>**Default:** 'auto' |
| `max_retries_for_selecting_speaker` | **Type:** int<br/><br/>**Default:** 2 |
| `allow_repeat_speaker` | **Type:** bool \| list[[Agent](/docs/api-reference/autogen/Agent)] \| None<br/><br/>**Default:** None |
| `allowed_or_disallowed_speaker_transitions` | **Type:** dict[str, typing.Any] \| None<br/><br/>**Default:** None |
| `speaker_transitions_type` | **Type:** Literal['allowed', 'disallowed', None]<br/><br/>**Default:** None |
| `enable_clear_history` | **Type:** bool<br/><br/>**Default:** False |
| `send_introductions` | **Type:** bool<br/><br/>**Default:** False |
| `select_speaker_message_template` | **Type:** str<br/><br/>**Default:** 'You are in a role play game. The following roles are available |
| `select_speaker_prompt_template` | **Type:** str<br/><br/>**Default:** 'Read the above conversation. Then select the next role from \{agentlist} to play. Only return the role.' |
| `select_speaker_auto_multiple_template` | **Type:** str<br/><br/>**Default:** 'You provided more than one name in your text, please return just the name of the next speaker. To determine the speaker use these prioritised rules |
| `select_speaker_auto_none_template` | **Type:** str<br/><br/>**Default:** 'You didn\'t choose a speaker. As a reminder, to determine the speaker use these prioritised rules |
| `select_speaker_transform_messages` | **Type:** [TransformMessages](/docs/api-reference/autogen/agentchat/contrib/capabilities/transform_messages/TransformMessages) \| None<br/><br/>**Default:** None |
| `select_speaker_auto_verbose` | **Type:** bool \| None<br/><br/>**Default:** False |
| `select_speaker_auto_model_client_cls` | **Type:** [ModelClient](/docs/api-reference/autogen/ModelClient) \| list[[ModelClient](/docs/api-reference/autogen/ModelClient)] \| None<br/><br/>**Default:** None |
| `select_speaker_auto_llm_config` | **Type:** dict[str, typing.Any] \| Literal[False] \| None<br/><br/>**Default:** None |
| `role_for_select_speaker_messages` | **Type:** str \| None<br/><br/>**Default:** 'system' |

### Class Attributes

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### DEFAULT_INTRO_MSG
<br />

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### admin_name
<br />

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### agents
<br />

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### allow_repeat_speaker
<br />

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### allowed_or_disallowed_speaker_transitions
<br />

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### allowed_speaker_transitions_dict
<br />

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### enable_clear_history
<br />

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### func_call_filter
<br />

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### max_retries_for_selecting_speaker
<br />

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### max_round
<br />

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### messages
<br />

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### role_for_select_speaker_messages
<br />

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### select_speaker_auto_llm_config
<br />

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### select_speaker_auto_model_client_cls
<br />

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### select_speaker_auto_multiple_template
<br />

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### select_speaker_auto_none_template
<br />

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### select_speaker_auto_verbose
<br />

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### select_speaker_message_template
<br />

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### select_speaker_prompt_template
<br />

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### select_speaker_transform_messages
<br />

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### send_introductions
<br />

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### speaker_selection_method
<br />

    <br />

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### speaker_transitions_type
<br />

    <br />

### Instance Attributes

<code class="doc-symbol doc-symbol-heading doc-symbol-attribute"></code>
#### agent_names
<br />

    Return the names of the agents in the group chat.

### Instance Methods

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### a_auto_select_speaker

```python
a_auto_select_speaker(
    self,
    last_speaker: Agent,
    selector: ConversableAgent,
    messages: list[dict[str, Any]] | None,
    agents: list[Agent] | None
) -> Agent
```

    (Asynchronous) Selects next speaker for the "auto" speaker selection method. Utilises its own two-agent chat to determine the next speaker and supports requerying.<br/>Speaker selection for "auto" speaker selection method: <br/>1. Create a two-agent chat with a speaker selector agent and a speaker validator agent, like a nested chat
    2. Inject the group messages into the new chat
    3. Run the two-agent chat, evaluating the result of response from the speaker selector agent: <br/>    - If a single agent is provided then we return it and finish. If not, we add an additional message to this nested chat in an attempt to guide the LLM to a single agent response
    4. Chat continues until a single agent is nominated or there are no more attempts left
    5. If we run out of turns and no single agent can be determined, the next speaker in the list of agents is returned

<b>Parameters:</b>
| Name | Description |
|--|--|
| `last_speaker` | **Type:** [Agent](/docs/api-reference/autogen/Agent) |
| `selector` | **Type:** [ConversableAgent](/docs/api-reference/autogen/ConversableAgent) |
| `messages` | **Type:** list[dict[str, typing.Any]] \| None |
| `agents` | **Type:** list[[Agent](/docs/api-reference/autogen/Agent)] \| None |

<b>Returns:</b>
| Type | Description |
|--|--|
| [Agent](/docs/api-reference/autogen/Agent) | Dict: a counter for mentioned agents. |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### a_select_speaker

```python
a_select_speaker(
    self,
    last_speaker: Agent,
    selector: ConversableAgent
) -> Agent
```

    Select the next speaker (with requery), asynchronously.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `last_speaker` | **Type:** [Agent](/docs/api-reference/autogen/Agent) |
| `selector` | **Type:** [ConversableAgent](/docs/api-reference/autogen/ConversableAgent) |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### agent_by_name

```python
agent_by_name(
    self,
    name: str,
    recursive: bool = False,
    raise_on_name_conflict: bool = False
) -> Agent | None
```

    Returns the agent with a given name. If recursive is True, it will search in nested teams.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `name` | **Type:** str |
| `recursive` | **Type:** bool<br/><br/>**Default:** False |
| `raise_on_name_conflict` | **Type:** bool<br/><br/>**Default:** False |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### append

```python
append(
    self,
    message: dict[str, Any],
    speaker: Agent
) -> 
```

    Append a message to the group chat.<br/>We cast the content to str here so that it can be managed by text-based
    model.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `message` | **Type:** dict[str, typing.Any] |
| `speaker` | **Type:** [Agent](/docs/api-reference/autogen/Agent) |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### introductions_msg

```python
introductions_msg(self, agents: list[Agent] | None = None) -> str
```

    Return the system message for selecting the next speaker. This is always the *first* message in the context.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `agents` | **Type:** list[[Agent](/docs/api-reference/autogen/Agent)] \| None<br/><br/>**Default:** None |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### manual_select_speaker

```python
manual_select_speaker(self, agents: list[Agent] | None = None) -> Agent | None
```

    Manually select the next speaker.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `agents` | **Type:** list[[Agent](/docs/api-reference/autogen/Agent)] \| None<br/><br/>**Default:** None |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### nested_agents

```python
nested_agents(self) -> list[Agent]
```

    Returns all agents in the group chat manager.

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### next_agent

```python
next_agent(
    self,
    agent: Agent,
    agents: list[Agent] | None = None
) -> Agent
```

    Return the next agent in the list.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `agent` | **Type:** [Agent](/docs/api-reference/autogen/Agent) |
| `agents` | **Type:** list[[Agent](/docs/api-reference/autogen/Agent)] \| None<br/><br/>**Default:** None |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### random_select_speaker

```python
random_select_speaker(self, agents: list[Agent] | None = None) -> Agent | None
```

    Randomly select the next speaker.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `agents` | **Type:** list[[Agent](/docs/api-reference/autogen/Agent)] \| None<br/><br/>**Default:** None |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### reset

```python
reset(self) -> 
```

    Reset the group chat.

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### select_speaker

```python
select_speaker(
    self,
    last_speaker: Agent,
    selector: ConversableAgent
) -> Agent
```

    Select the next speaker (with requery).

<b>Parameters:</b>
| Name | Description |
|--|--|
| `last_speaker` | **Type:** [Agent](/docs/api-reference/autogen/Agent) |
| `selector` | **Type:** [ConversableAgent](/docs/api-reference/autogen/ConversableAgent) |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### select_speaker_msg

```python
select_speaker_msg(self, agents: list[Agent] | None = None) -> str
```

    Return the system message for selecting the next speaker. This is always the *first* message in the context.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `agents` | **Type:** list[[Agent](/docs/api-reference/autogen/Agent)] \| None<br/><br/>**Default:** None |

<br />

<code class="doc-symbol doc-symbol-heading doc-symbol-method"></code>
#### select_speaker_prompt

```python
select_speaker_prompt(self, agents: list[Agent] | None = None) -> str
```

    Return the floating system prompt selecting the next speaker.<br/>This is always the *last* message in the context.<br/>Will return None if the select_speaker_prompt_template is None.

<b>Parameters:</b>
| Name | Description |
|--|--|
| `agents` | **Type:** list[[Agent](/docs/api-reference/autogen/Agent)] \| None<br/><br/>**Default:** None |

<br />